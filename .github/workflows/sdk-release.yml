name: Comprehensive SDK Distribution Pipeline

on:
  push:
    paths:
      - 'sdk/**'
    tags:
      - 'sdk/v*'
  pull_request:
    paths:
      - 'sdk/**'
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even on non-tag builds'
        required: false
        type: boolean
        default: false
      release_type:
        description: 'Type of release (patch, minor, major)'
        required: false
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

env:
  GO_VERSION: '1.24.6'
  GOTOOLCHAIN: 'go1.24.6'
  SDK_PATH: './sdk'
  REGISTRY: ghcr.io

permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

jobs:
  # Emergency cleanup job for SDK artifacts
  cleanup:
    name: SDK Artifact Cleanup
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
    - name: Cleanup old SDK artifacts
      uses: actions/github-script@v7
      with:
        script: |
          const cutoffDate = new Date(Date.now() - (3 * 60 * 60 * 1000)); // 3 hours ago
          let page = 1;
          let totalDeleted = 0;
          
          while (page <= 5) {
            const { data: artifacts } = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
              page: page
            });
            
            if (artifacts.artifacts.length === 0) break;
            
            for (const artifact of artifacts.artifacts) {
              if (artifact.name.includes('sdk') && new Date(artifact.created_at) < cutoffDate) {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id
                });
                totalDeleted++;
              }
            }
            page++;
          }
          console.log(`ğŸ§¹ SDK cleanup: deleted ${totalDeleted} old artifacts`);

  # Generate SDK version and metadata
  metadata:
    name: Generate SDK Metadata
    runs-on: ubuntu-latest
    needs: cleanup
    outputs:
      sdk_version: ${{ steps.version.outputs.sdk_version }}
      is_release: ${{ steps.version.outputs.is_release }}
      git_commit: ${{ steps.version.outputs.git_commit }}
      build_date: ${{ steps.version.outputs.build_date }}
      go_version: ${{ steps.version.outputs.go_version }}
      release_notes: ${{ steps.notes.outputs.release_notes }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Generate Version Information
      id: version
      run: |
        # Determine if this is a release build
        IS_RELEASE="false"
        if [[ "$GITHUB_REF" =~ refs/tags/sdk/v.* ]] || [[ "${{ github.event.inputs.force_release }}" == "true" ]]; then
          IS_RELEASE="true"
        fi
        
        # Generate SDK version
        if [[ "$GITHUB_REF" =~ refs/tags/sdk/v.* ]]; then
          SDK_VERSION="${GITHUB_REF#refs/tags/sdk/}"
        elif [[ "${{ github.event.inputs.force_release }}" == "true" ]]; then
          # Generate version based on release type
          CURRENT_VERSION=$(git describe --tags --match "sdk/v*" --abbrev=0 2>/dev/null | sed 's/sdk\/v//' || echo "0.1.0")
          case "${{ github.event.inputs.release_type }}" in
            "major") SDK_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1+1".0.0"}') ;;
            "minor") SDK_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2+1".0"}') ;;
            "patch") SDK_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."$3+1}') ;;
            *) SDK_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."$3+1}') ;;
          esac
          SDK_VERSION="v${SDK_VERSION}"
        else
          # Development version
          GIT_TAG=$(git describe --tags --match "sdk/v*" --abbrev=0 2>/dev/null | sed 's/sdk\///' || echo "v0.1.0")
          GIT_COMMIT=$(git rev-parse --short HEAD)
          BUILD_NUMBER=${{ github.run_number }}
          SDK_VERSION="${GIT_TAG}-dev.${BUILD_NUMBER}+${GIT_COMMIT}"
        fi
        
        echo "sdk_version=${SDK_VERSION}" >> $GITHUB_OUTPUT
        echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
        echo "git_commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        echo "build_date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
        echo "go_version=${{ env.GO_VERSION }}" >> $GITHUB_OUTPUT
        
        echo "ğŸ“¦ SDK Version: ${SDK_VERSION}"
        echo "ğŸ·ï¸ Is Release: ${IS_RELEASE}"
        
    - name: Generate Release Notes
      id: notes
      run: |
        if [[ "${{ steps.version.outputs.is_release }}" == "true" ]]; then
          # Generate comprehensive release notes
          RELEASE_NOTES=$(cat << 'EOF'
        ## ğŸš€ Kolumn SDK ${{ steps.version.outputs.sdk_version }}
        
        ### ğŸ¯ What's New
        - Enhanced provider development framework
        - Improved RPC communication system
        - Advanced state management capabilities
        - Comprehensive testing utilities
        - Provider template generation tools
        
        ### ğŸ“š Documentation & Examples
        - Complete API documentation
        - Provider development tutorials
        - Real-world usage examples
        - Best practices guide
        
        ### ğŸ› ï¸ Developer Experience
        - Streamlined provider scaffolding
        - Automated testing framework
        - IDE integration support
        - Debug tools and utilities
        
        ### ğŸ“¦ Installation
        
        **Go Module:**
        ```bash
        go get github.com/schemabounce/kolumn/sdk@${{ steps.version.outputs.sdk_version }}
        ```
        
        **Provider Template Generator:**
        ```bash
        curl -sSL https://github.com/schemabounce/kolumn/releases/download/sdk/${{ steps.version.outputs.sdk_version }}/kolumn-provider-template-linux-amd64.tar.gz | tar xz
        ./kolumn-provider-template init my-provider
        ```
        
        ### ğŸ”— Quick Links
        - [SDK Documentation](https://github.com/schemabounce/kolumn/tree/main/sdk)
        - [Provider Examples](https://github.com/schemabounce/kolumn/tree/main/sdk/examples)
        - [Development Guide](https://github.com/schemabounce/kolumn/blob/main/sdk/README.md)
        EOF
        )
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo "release_notes=Development build - see commit history for changes" >> $GITHUB_OUTPUT
        fi

  # Comprehensive SDK Testing
  test:
    name: SDK Test Suite
    runs-on: ${{ matrix.os }}
    needs: metadata
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        go-version: ['1.24.6']
    
    defaults:
      run:
        working-directory: ${{ env.SDK_PATH }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup Go ${{ matrix.go-version }}
      uses: actions/setup-go@v5
      with:
        go-version: ${{ matrix.go-version }}
        cache-dependency-path: ${{ env.SDK_PATH }}/go.sum
        
    - name: Download Dependencies
      run: make deps
      
    - name: Run Unit Tests
      run: make test
      
    - name: Run Integration Tests
      run: |
        # Test SDK components integration
        go test -v -tags integration ./...
      
    - name: Generate Test Coverage (Linux only)
      if: matrix.os == 'ubuntu-latest'
      run: make test-coverage
      
    - name: Upload Coverage to Codecov (Linux only)
      if: matrix.os == 'ubuntu-latest'
      uses: codecov/codecov-action@v4
      with:
        file: ${{ env.SDK_PATH }}/build/coverage.out
        flags: sdk
        name: sdk-coverage-${{ matrix.os }}-go${{ matrix.go-version }}

  # Code Quality and Security
  quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    needs: metadata
    defaults:
      run:
        working-directory: ${{ env.SDK_PATH }}
        
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache-dependency-path: ${{ env.SDK_PATH }}/go.sum
        
    - name: Run Linters
      run: make lint
      
    - name: Run go vet
      run: make vet
      
    - name: Check Code Formatting
      run: |
        make fmt
        git diff --exit-code || (echo "âŒ Code not formatted. Run 'make fmt'" && exit 1)
        
    - name: Vulnerability Scan
      uses: securecodewarrior/github-action-gosec@master
      with:
        args: '-fmt sarif -out gosec.sarif ${{ env.SDK_PATH }}/...'
        
    - name: Upload Security Scan Results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: gosec.sarif
        
    - name: License Compliance Check
      run: |
        echo "ğŸ” Checking license compliance..."
        # Check for prohibited licenses
        go list -m -json all | jq -r '.Path' | while read -r module; do
          if [[ "$module" == *"gpl"* ]] || [[ "$module" == *"agpl"* ]]; then
            echo "âŒ Prohibited license found in module: $module"
            exit 1
          fi
        done
        echo "âœ… License compliance check passed"

  # Build SDK and Artifacts  
  build:
    name: Build SDK Artifacts
    runs-on: ubuntu-latest
    needs: [metadata, test, quality]
    outputs:
      artifacts_created: ${{ steps.build.outputs.artifacts_created }}
    defaults:
      run:
        working-directory: ${{ env.SDK_PATH }}
        
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache-dependency-path: ${{ env.SDK_PATH }}/go.sum
        
    - name: Build SDK Components
      id: build
      run: |
        echo "ğŸ”¨ Building SDK components for version ${{ needs.metadata.outputs.sdk_version }}"
        
        # Create build directories
        mkdir -p build/{sdk,templates,docs,examples,tools}
        
        # Build SDK library
        echo "ğŸ“¦ Building SDK library..."
        go build $(GO_BUILD_FLAGS) ./...
        
        # Build examples
        echo "ğŸ—ï¸ Building examples..."
        make examples
        
        # Generate comprehensive documentation
        echo "ğŸ“š Generating documentation..."
        make docs
        
        # Generate API documentation
        go doc -all ./... > build/docs/api-reference.txt
        
        # Create SDK package information
        cat > build/sdk/sdk-info.json << EOF
        {
          "version": "${{ needs.metadata.outputs.sdk_version }}",
          "go_version": "${{ needs.metadata.outputs.go_version }}",
          "git_commit": "${{ needs.metadata.outputs.git_commit }}",
          "build_date": "${{ needs.metadata.outputs.build_date }}",
          "is_release": ${{ needs.metadata.outputs.is_release }},
          "components": {
            "rpc": "RPC communication framework",
            "state": "State management system", 
            "pdk": "Provider Development Kit",
            "testing": "Testing utilities",
            "types": "Type definitions"
          }
        }
        EOF
        
        echo "artifacts_created=true" >> $GITHUB_OUTPUT
        echo "âœ… SDK build completed successfully"
        
    - name: Upload SDK Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sdk-build-${{ needs.metadata.outputs.sdk_version }}
        path: ${{ env.SDK_PATH }}/build/
        retention-days: 5
        compression-level: 9

  # Generate Provider Templates and Scaffolding
  templates:
    name: Generate Provider Templates
    runs-on: ubuntu-latest
    needs: [metadata, build]
    strategy:
      matrix:
        template: [
          { name: "minimal", desc: "Minimal provider template" },
          { name: "database", desc: "Database provider template" },
          { name: "api", desc: "API-based provider template" },
          { name: "streaming", desc: "Streaming provider template" }
        ]
        platform: [
          { goos: "linux", goarch: "amd64" },
          { goos: "linux", goarch: "arm64" },
          { goos: "darwin", goarch: "amd64" },
          { goos: "darwin", goarch: "arm64" },
          { goos: "windows", goarch: "amd64" }
        ]
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        
    - name: Create Provider Template Generator
      run: |
        # Create provider template generator tool
        mkdir -p tools/provider-template-generator
        
        cat > tools/provider-template-generator/main.go << 'EOF'
        package main
        
        import (
            "fmt"
            "log"
            "os"
            "path/filepath"
            "strings"
            "text/template"
        )
        
        type TemplateData struct {
            ProviderName    string
            ProviderNameCap string
            ModulePath      string
            SDKVersion      string
            GoVersion       string
            Year            string
        }
        
        func main() {
            if len(os.Args) < 4 {
                log.Fatal("Usage: provider-template-generator <template-type> <provider-name> <output-dir>")
            }
            
            templateType := os.Args[1]
            providerName := os.Args[2] 
            outputDir := os.Args[3]
            
            data := TemplateData{
                ProviderName:    providerName,
                ProviderNameCap: strings.Title(providerName),
                ModulePath:      fmt.Sprintf("github.com/myorg/kolumn-provider-%s", providerName),
                SDKVersion:      "${{ needs.metadata.outputs.sdk_version }}",
                GoVersion:       "${{ needs.metadata.outputs.go_version }}",
                Year:           "2025",
            }
            
            templates := getTemplates(templateType)
            
            for filename, content := range templates {
                fullPath := filepath.Join(outputDir, filename)
                os.MkdirAll(filepath.Dir(fullPath), 0755)
                
                tmpl, err := template.New(filename).Parse(content)
                if err != nil {
                    log.Fatalf("Template parse error for %s: %v", filename, err)
                }
                
                file, err := os.Create(fullPath)
                if err != nil {
                    log.Fatalf("File creation error for %s: %v", fullPath, err)
                }
                defer file.Close()
                
                err = tmpl.Execute(file, data)
                if err != nil {
                    log.Fatalf("Template execution error for %s: %v", filename, err)
                }
            }
            
            fmt.Printf("âœ… Generated %s provider template for '%s' in %s\n", templateType, providerName, outputDir)
        }
        
        func getTemplates(templateType string) map[string]string {
            switch templateType {
            case "minimal":
                return getMinimalTemplates()
            case "database":
                return getDatabaseTemplates()
            case "api":
                return getAPITemplates()
            case "streaming":
                return getStreamingTemplates()
            default:
                return getMinimalTemplates()
            }
        }
        
        func getMinimalTemplates() map[string]string {
            return map[string]string{
                "go.mod": `module {{.ModulePath}}
        
        go {{.GoVersion}}
        
        require (
            github.com/schemabounce/kolumn/sdk {{.SDKVersion}}
        )`,
                "main.go": `package main
        
        import (
            "context"
            "log"
            
            "github.com/schemabounce/kolumn/sdk/rpc"
        )
        
        func main() {
            provider := &{{.ProviderNameCap}}Provider{}
            
            log.Printf("Starting {{.ProviderNameCap}} provider...")
            
            err := rpc.ServeProvider(context.Background(), provider)
            if err != nil {
                log.Fatalf("Provider error: %v", err)
            }
        }
        
        type {{.ProviderNameCap}}Provider struct{}
        
        func (p *{{.ProviderNameCap}}Provider) Configure(ctx context.Context, config map[string]interface{}) error {
            log.Printf("Configuring {{.ProviderName}} provider")
            return nil
        }
        
        func (p *{{.ProviderNameCap}}Provider) GetSchema(ctx context.Context) (map[string]interface{}, error) {
            return map[string]interface{}{
                "resources": map[string]interface{}{
                    "{{.ProviderName}}_resource": map[string]interface{}{
                        "schema": map[string]interface{}{
                            "name": map[string]interface{}{
                                "type": "string",
                                "required": true,
                            },
                        },
                    },
                },
            }, nil
        }
        
        func (p *{{.ProviderNameCap}}Provider) CallFunction(ctx context.Context, function string, args map[string]interface{}) (interface{}, error) {
            log.Printf("Calling function: %s", function)
            return nil, nil
        }
        
        func (p *{{.ProviderNameCap}}Provider) Close() error {
            log.Printf("Closing {{.ProviderName}} provider")
            return nil
        }`,
                "README.md": `# Kolumn {{.ProviderNameCap}} Provider
        
        This provider was generated using the Kolumn SDK {{.SDKVersion}}.
        
        ## Development
        
        \`\`\`bash
        go mod tidy
        go build -o kolumn-provider-{{.ProviderName}}
        \`\`\`
        
        ## Usage
        
        \`\`\`hcl
        provider "{{.ProviderName}}" {
          # Configuration options
        }
        
        create "{{.ProviderName}}_resource" "example" {
          name = "my-resource"
        }
        \`\`\``,
            }
        }
        
        func getDatabaseTemplates() map[string]string {
            templates := getMinimalTemplates()
            templates["database.go"] = `package main
        
        import (
            "context"
            "database/sql"
        )
        
        type DatabaseProvider struct {
            db *sql.DB
        }
        
        func (p *DatabaseProvider) Connect(ctx context.Context, connectionString string) error {
            // Database connection logic
            return nil
        }
        
        func (p *DatabaseProvider) CreateTable(ctx context.Context, name string, schema interface{}) error {
            // Table creation logic  
            return nil
        }`
            return templates
        }
        
        func getAPITemplates() map[string]string {
            templates := getMinimalTemplates()
            templates["client.go"] = `package main
        
        import (
            "context"
            "net/http"
        )
        
        type APIProvider struct {
            client *http.Client
            baseURL string
        }
        
        func (p *APIProvider) makeRequest(ctx context.Context, method, endpoint string, body interface{}) error {
            // API request logic
            return nil
        }`
            return templates  
        }
        
        func getStreamingTemplates() map[string]string {
            templates := getMinimalTemplates()
            templates["stream.go"] = `package main
        
        import (
            "context"
        )
        
        type StreamingProvider struct {
            brokers []string
        }
        
        func (p *StreamingProvider) CreateTopic(ctx context.Context, name string, partitions int) error {
            // Topic creation logic
            return nil
        }
        
        func (p *StreamingProvider) PublishMessage(ctx context.Context, topic string, message interface{}) error {
            // Message publishing logic
            return nil
        }`
            return templates
        }
        EOF
        
    - name: Build Template Generator
      run: |
        cd tools/provider-template-generator
        GOOS=${{ matrix.platform.goos }} GOARCH=${{ matrix.platform.goarch }} \
        go build -o kolumn-provider-template-${{ matrix.platform.goos }}-${{ matrix.platform.goarch }} .
        
    - name: Generate Template Archive
      run: |
        mkdir -p templates/${{ matrix.template.name }}
        cd tools/provider-template-generator
        
        # Generate template files for this template type
        ./kolumn-provider-template-${{ matrix.platform.goos }}-${{ matrix.platform.goarch }} \
          ${{ matrix.template.name }} example-provider ../../templates/${{ matrix.template.name }}/
        
        cd ../../templates/${{ matrix.template.name }}/
        
        # Add template metadata
        cat > template-info.json << EOF
        {
          "name": "${{ matrix.template.name }}",
          "description": "${{ matrix.template.desc }}",
          "sdk_version": "${{ needs.metadata.outputs.sdk_version }}",
          "go_version": "${{ needs.metadata.outputs.go_version }}",
          "created_at": "${{ needs.metadata.outputs.build_date }}"
        }
        EOF
        
        # Create archive
        cd ../
        tar -czf kolumn-provider-template-${{ matrix.template.name }}-${{ matrix.platform.goos }}-${{ matrix.platform.goarch }}.tar.gz ${{ matrix.template.name }}/
        
    - name: Upload Template Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: provider-templates-${{ matrix.template.name }}-${{ matrix.platform.goos }}-${{ matrix.platform.goarch }}
        path: |
          templates/kolumn-provider-template-${{ matrix.template.name }}-${{ matrix.platform.goos }}-${{ matrix.platform.goarch }}.tar.gz
          tools/provider-template-generator/kolumn-provider-template-${{ matrix.platform.goos }}-${{ matrix.platform.goarch }}
        retention-days: 5

  # Generate Comprehensive Documentation
  docs:
    name: Generate Documentation
    runs-on: ubuntu-latest  
    needs: [metadata, build]
    defaults:
      run:
        working-directory: ${{ env.SDK_PATH }}
        
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache-dependency-path: ${{ env.SDK_PATH }}/go.sum
        
    - name: Install Documentation Tools
      run: |
        go install golang.org/x/tools/cmd/godoc@latest
        go install github.com/swaggo/swag/cmd/swag@latest
        
    - name: Generate API Documentation
      run: |
        mkdir -p build/docs/{api,guides,examples,reference}
        
        # Generate godoc documentation  
        echo "ğŸ“š Generating API documentation..."
        go doc -all ./... > build/docs/api/godoc.txt
        
        # Generate package documentation
        for pkg in rpc state pdk types testing metadata; do
          echo "ğŸ“– Documenting package: $pkg"
          go doc -all ./$pkg > build/docs/api/$pkg.md
        done
        
        # Create comprehensive developer guide
        cat > build/docs/guides/getting-started.md << 'EOF'
        # Getting Started with Kolumn SDK
        
        ## Installation
        
        ```bash
        go get github.com/schemabounce/kolumn/sdk@${{ needs.metadata.outputs.sdk_version }}
        ```
        
        ## Quick Start
        
        1. **Create a new provider project:**
        ```bash
        mkdir my-provider && cd my-provider
        go mod init github.com/myorg/kolumn-provider-mydb
        ```
        
        2. **Add Kolumn SDK dependency:**
        ```bash
        go get github.com/schemabounce/kolumn/sdk@${{ needs.metadata.outputs.sdk_version }}
        ```
        
        3. **Implement your provider:**
        ```go
        package main
        
        import (
            "context"
            "github.com/schemabounce/kolumn/sdk/rpc"
        )
        
        type MyProvider struct{}
        
        func (p *MyProvider) Configure(ctx context.Context, config map[string]interface{}) error {
            return nil
        }
        
        func (p *MyProvider) GetSchema(ctx context.Context) (map[string]interface{}, error) {
            return map[string]interface{}{}, nil
        }
        
        func (p *MyProvider) CallFunction(ctx context.Context, function string, args map[string]interface{}) (interface{}, error) {
            return nil, nil
        }
        
        func (p *MyProvider) Close() error {
            return nil
        }
        
        func main() {
            provider := &MyProvider{}
            rpc.ServeProvider(context.Background(), provider)
        }
        ```
        
        ## Architecture Overview
        
        The Kolumn SDK provides:
        
        - **RPC Framework**: Handles communication between core Kolumn and providers
        - **State Management**: Persistent state handling with multiple backends  
        - **Provider Development Kit (PDK)**: Utilities and helpers for provider development
        - **Testing Framework**: Comprehensive testing utilities
        - **Type System**: Strong typing for resources and configurations
        
        ## Provider Development Workflow
        
        1. **Design**: Define your provider's resources and data sources
        2. **Implement**: Use SDK components to build your provider
        3. **Test**: Utilize SDK testing framework
        4. **Package**: Build provider binary for distribution
        5. **Distribute**: Publish provider for others to use
        EOF
        
        # Create best practices guide
        cat > build/docs/guides/best-practices.md << 'EOF'
        # Provider Development Best Practices
        
        ## Code Organization
        
        - Separate resource logic into individual files
        - Use consistent naming conventions
        - Implement comprehensive error handling
        - Add logging for debugging
        
        ## State Management
        
        - Always persist resource state
        - Implement proper dependency tracking
        - Handle state corruption gracefully
        - Support state migration
        
        ## Testing
        
        - Write unit tests for all functions
        - Use SDK testing utilities
        - Test error conditions
        - Validate state persistence
        
        ## Performance
        
        - Implement connection pooling
        - Use caching where appropriate
        - Handle timeouts gracefully
        - Optimize for common operations
        
        ## Security
        
        - Validate all inputs
        - Handle credentials securely
        - Use TLS for network communications
        - Audit security regularly
        EOF
        
        echo "âœ… Documentation generation completed"
        
    - name: Upload Documentation Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sdk-documentation-${{ needs.metadata.outputs.sdk_version }}
        path: ${{ env.SDK_PATH }}/build/docs/
        retention-days: 7

  # Integration Testing with External Provider Simulation
  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [metadata, build, templates]
    defaults:
      run:
        working-directory: ${{ env.SDK_PATH }}
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache-dependency-path: ${{ env.SDK_PATH }}/go.sum
        
    - name: Download Template Artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: provider-templates-minimal-linux-amd64
        path: ./test-templates/
        merge-multiple: true
        
    - name: Test Template Generation
      run: |
        echo "ğŸ§ª Testing template generation..."
        
        # Extract template generator
        cd ../test-templates
        chmod +x kolumn-provider-template-linux-amd64
        
        # Generate test provider
        mkdir -p test-provider
        ./kolumn-provider-template-linux-amd64 minimal test-provider ./test-provider/
        
        # Test the generated provider compiles
        cd test-provider
        go mod tidy
        go build -o test-provider .
        
        echo "âœ… Template generation test passed"
        
    - name: Test Core Integration
      run: |
        echo "ğŸ§ª Testing core Kolumn integration..."
        cd ..
        
        # Build core Kolumn with SDK
        go build -v ./cmd/kolumn
        
        # Test SDK version compatibility
        ./kolumn version
        
        echo "âœ… Core integration test passed"
        
    - name: Test RPC Communication
      run: |
        echo "ğŸ§ª Testing RPC communication..."
        
        # Test RPC server/client functionality
        go test -v -tags integration ./rpc/...
        
        echo "âœ… RPC communication test passed"

  # GitHub Packages Publication
  publish:
    name: Publish to GitHub Packages
    runs-on: ubuntu-latest
    needs: [metadata, build, templates, docs, integration]
    if: needs.metadata.outputs.is_release == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        
    - name: Configure Git for Go Modules
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        
    - name: Publish SDK Module
      run: |
        echo "ğŸ“¦ Publishing SDK to GitHub Packages..."
        
        # The go.mod already defines the module path, so we just need to push tags
        # Go modules are automatically available once tagged
        
        SDK_VERSION="${{ needs.metadata.outputs.sdk_version }}"
        
        # Create and push SDK tag if it doesn't exist
        if ! git rev-parse "sdk/${SDK_VERSION}" >/dev/null 2>&1; then
          git tag "sdk/${SDK_VERSION}"
          git push origin "sdk/${SDK_VERSION}"
          echo "âœ… SDK tag sdk/${SDK_VERSION} created and pushed"
        else
          echo "â„¹ï¸ SDK tag sdk/${SDK_VERSION} already exists"
        fi
        
    - name: Verify Module Availability
      run: |
        echo "ğŸ” Verifying SDK module availability..."
        
        # Test that the module can be fetched
        go list -m github.com/schemabounce/kolumn/sdk@${{ needs.metadata.outputs.sdk_version }}
        
        echo "âœ… SDK module is available at github.com/schemabounce/kolumn/sdk@${{ needs.metadata.outputs.sdk_version }}"

  # Create GitHub Release with Artifacts
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [metadata, build, templates, docs, integration, publish]
    if: needs.metadata.outputs.is_release == 'true'
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Download All Artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./release-artifacts/
        
    - name: Prepare Release Assets
      run: |
        echo "ğŸ“¦ Preparing release assets..."
        
        mkdir -p release-assets
        
        # Organize artifacts
        find ./release-artifacts -name "*.tar.gz" -exec cp {} ./release-assets/ \;
        find ./release-artifacts -name "kolumn-provider-template-*" -type f -executable -exec cp {} ./release-assets/ \;
        
        # Create SDK source archive
        git archive --format=tar.gz --prefix=kolumn-sdk-${{ needs.metadata.outputs.sdk_version }}/ \
          --output=./release-assets/kolumn-sdk-${{ needs.metadata.outputs.sdk_version }}-source.tar.gz HEAD:sdk/
        
        # Create checksums
        cd release-assets
        sha256sum * > checksums.sha256
        
        echo "ğŸ“Š Release assets prepared:"
        ls -la
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: sdk/${{ needs.metadata.outputs.sdk_version }}
        name: Kolumn SDK ${{ needs.metadata.outputs.sdk_version }}
        body: ${{ needs.metadata.outputs.release_notes }}
        draft: false
        prerelease: ${{ contains(needs.metadata.outputs.sdk_version, '-') }}
        files: |
          ./release-assets/*
        token: ${{ secrets.GITHUB_TOKEN }}

  # Notification and Summary
  summary:
    name: Distribution Summary
    runs-on: ubuntu-latest
    needs: [metadata, test, quality, build, templates, docs, integration, publish, release]
    if: always()
    
    steps:
    - name: Generate Distribution Summary
      run: |
        echo "ğŸ‰ Kolumn SDK Distribution Summary"
        echo "=================================="
        echo ""
        echo "ğŸ“¦ **SDK Version:** ${{ needs.metadata.outputs.sdk_version }}"
        echo "ğŸ·ï¸ **Release Build:** ${{ needs.metadata.outputs.is_release }}"
        echo "ğŸ”¨ **Build Date:** ${{ needs.metadata.outputs.build_date }}"
        echo "ğŸ¹ **Go Version:** ${{ needs.metadata.outputs.go_version }}"
        echo ""
        echo "âœ… **Pipeline Status:**"
        echo "   - Tests: ${{ needs.test.result }}"
        echo "   - Quality: ${{ needs.quality.result }}"  
        echo "   - Build: ${{ needs.build.result }}"
        echo "   - Templates: ${{ needs.templates.result }}"
        echo "   - Docs: ${{ needs.docs.result }}"
        echo "   - Integration: ${{ needs.integration.result }}"
        echo "   - Publish: ${{ needs.publish.result }}"
        echo "   - Release: ${{ needs.release.result }}"
        echo ""
        echo "ğŸš€ **Artifacts Generated:**"
        echo "   - SDK Go Module"
        echo "   - Provider Templates (4 types Ã— 5 platforms = 20 archives)"
        echo "   - Template Generators (5 platforms)"
        echo "   - Comprehensive Documentation"
        echo "   - API Reference"
        echo "   - Developer Guides"
        echo ""
        echo "ğŸ“– **Installation:**"
        echo "   \`go get github.com/schemabounce/kolumn/sdk@${{ needs.metadata.outputs.sdk_version }}\`"
        echo ""
        echo "ğŸ”— **Resources:**"
        echo "   - [SDK Documentation](https://github.com/schemabounce/kolumn/tree/main/sdk)"
        echo "   - [Provider Templates](https://github.com/schemabounce/kolumn/releases/tag/sdk/${{ needs.metadata.outputs.sdk_version }})"
        echo "   - [Developer Guides](https://github.com/schemabounce/kolumn/tree/main/sdk/docs)"
        echo ""
        if [[ "${{ needs.metadata.outputs.is_release }}" == "true" ]]; then
          echo "ğŸŠ **Release successfully published!**"
        else
          echo "ğŸ”§ **Development build completed successfully!**"
        fi